// === Step 1: Trusted domains allowlist (with domain length precomputed) ===
// These are domains we consider safe and legitimate.
let trustedDomains = datatable(domain:string, len:int)
[
  "google.com", 10,
  "microsoft.com", 13,
  "amazon.com", 10,
  "paypal.com", 10,
  "apple.com", 9,
  "icloud.com", 10,
  "facebook.com", 12,
  "netflix.com", 11,
  "wellsfargo.com", 13,
  "linkedin.com", 11,
  "dropbox.com", 10,
  "bankofamerica.com", 17,
  "rbc.com", 7,
  "instagram.com", 12,
  "adobe.com", 9,
  "salesforce.com", 14,
  "aws.amazon.com", 15,
  "hulu.com", 8,
  "disneyplus.com", 14,
  "gmail.com", 9
];
// === Step 2: Extract domains from DeviceNetworkEvents ===
// We're only interested in DNS query events with a RemoteUrl.
// We lowercase and normalize the domain part from the URL.
let allDns =
    DeviceNetworkEvents
    | where ActionType == "DnsQuery" and isnotempty(RemoteUrl)
    | extend domainQueried = tolower(split(RemoteUrl, "/")[0])
    | project domainQueried, source = "DeviceNetworkEvents"
    | summarize by domainQueried, source
;
// === Step 3: Exclude any domains that exactly match the trusted list ===
// This gives us only the "unknown" domains that we want to investigate further.
let unknownDomains =
    allDns
    | join kind=leftanti (trustedDomains) on $left.domainQueried == $right.domain
;
// === Step 4: Create dummy join key to simulate cartesian join ===
// We'll compare each unknown domain against every trusted domain (with some length filtering).
let unknownWithKey = unknownDomains | extend joinKey = 1;
let trustedWithKey = trustedDomains | extend joinKey = 1;
// === Step 5: Fuzzy similarity comparison using a character difference heuristic ===
// For each unknown vs. trusted domain pair:
//   - If domain lengths are within ±3, proceed
//   - Use `mv-apply` to explode characters and compare them based on position tags
unknownWithKey
| join kind=inner (trustedWithKey) on joinKey
| extend len1 = strlen(domainQueried)
| where abs(len1 - len) <= 3  // avoid comparing domains with vastly different lengths
| mv-apply 
    chars = extract_all(@"(.)", strcat(domainQueried, domain)),  // break characters into array
    tag = array_concat(repeat("1", len1), repeat("2", len))      // tag chars: '1' = unknown, '2' = trusted
    to typeof(string)
    on (
        summarize count_diff = countif(tag == "2") - countif(tag == "1") by tostring(chars)
        | extend count_diff_abs = abs(count_diff)
    )
// === Step 6: Aggregate similarity metrics and compute a ratio ===
// - diff_absolute: rough measure of how different the domain is
// - similarityRatio: normalized score (lower = more similar)
| summarize diff_absolute = sum(count_diff_abs) by domainQueried, domainTrusted=domain, source, len1
| extend diff_absolute2 = iff(diff_absolute == 0, 0.1, toreal(diff_absolute))  // avoid division by 0
| extend similarityRatio = round(diff_absolute2 / len1, 2)
| where similarityRatio < 0.4 and domainQueried != domainTrusted  // filter for suspicious lookalikes
| order by similarityRatio asc  // most suspicious first
// === Fuzzy Logic Explanation ===
// This query uses a simple character-difference heuristic to detect domain lookalikes (e.g., "paypa1.com" vs "paypal.com").
// It tags characters from the unknown and trusted domains, then counts how many extra or missing characters exist between them.
// The total difference is normalized into a similarity ratio — lower values indicate higher similarity and higher potential for typosquatting.

